* store lambda box in op instead of alloc on eval
** create on init
** add op.deinit to clear
---
* add emit
** add op_type.emit like eval
*** write C to buf
** add bin emit fn
*** like compile
*** return str
** duffs device/switch
*** labels for lambdas
*** call fn recursively
** replace scan_args 
*** add cx.func
*** check after each relevant op
*** call fn if enough args and error if no match
* ---
* add rat sub/div
* add rat tests
* add Stream type
** cx_stream with byte vec & r/w pos
** stream fn to create
** stream '...' write fn
** stream rseek/wseek fn
** stream str fn
** stream len fn
* add nvect fn
** vect of len n
** init to nil
* add vect put/get to/from index
** check bounds
* add type.cmp
** add Cmp trait
** use to implement < > <= >= for all Cmp types
** use as fallback for eqval
** replaces int/rat imps
** add cx_init_cmp_type
* add Table type
* add struct: macro
** add Struct type 
*** add to parents for all structs
** add cx_type.trait
*** set to true for all user defined traits
** only allow Structs and traits as parents
** use ref counted sets of cx_struct_slot as instances
* add fail func
** like test but just call error with message
* add basic io
** add ask fn from main
*** read from stdin until newline with prompt
** add say fn from main
*** write to stdout with newline
* add str \n support
* add str \' support

* add cx_init_io with load fn
** load first repl arg if any
** push rest on stack
* add Str 'int' fn
* add Int 'str' fn
* add Char 'int' fn
* add Int 'char' fn
* add lets: macro
** typecheck and bind stack to vars
* add str interpolation

| clock {,10000 times {,fib 50 _}} / 1000000 int
