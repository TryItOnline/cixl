* implement Rec print like Table
* implement Rec Cmp to compare pointers
* implement Vec Cmp to compare values
* improve cut
** add struct cx_cut
** tag with func in scan if empty
** only remove if same func
** replace parens in bookings
* rename test to check
* rename type.print to dump
** add dump fn to get str for any value
* change _ to func
** add stack lib
*** move |, %, %%, ~ & _
* meta lib with read-iter
** move read and convert to iter
*** keep bin ref in iter
* add iter zip/unzip
* add defer(any) fn
** add scope.deferred
*** vec of boxes
*** call in cx_end()
* add and/or tests
* add filter tests
* extract cond lib with if/?/!
* extract func lib with func:/call/recall/upcall
* add Table type
** extract cx_table from Rec
** allow specifying key
** add $resources table
* add type: macro
** type: Size Int
*** size 42 -> Size(42)
*** inherit and register conversion fns
* add ^ (pow)
** add as separator
** implement for int/rat in math
* add seek(File offs)
** seek from start
* add len(File)
*** save offs end seek 0 from end

* add vect put/get fns
* add rat sub/div
** move fns to math lib

* add lets: macro
** typecheck and bind stack to vars
* implement Cmp for Sym/Guid/Vect/Rec
* use cx_str for CX_TID
** remove cx_tok.as_ptr
** replace with cx_tok.as_str, as_func, as_fimp etc.
* replace box.as_ptr with as_func/fimp/etc
* implement type.new for Int/Str/Rat/Time
** execute first clause that tests ok
** error if no match 
* add str interpolation
* add Ref type

* add switch: macro
** var is optional
*** bind if not bound already
*** push before groups/funcs/fimps
** add cond lib
** if cond is group, eval
*** with g pushed if present
** if cond is literal, compare with =
*** only if var is present
** if cond is func/fimp, call
** if cond is $id, compare with =
*** only if var is present
** if #t, eval unconditionally
** allow single token actions
*** call eval_token instead
