* switch times arg order
* handle argv in emit main
** push strings like load main
* add trait: emit
** add OTYPEDEF
*** rename OFIMPDEF to OFUNCDEF
* add rec: emit
* add op_type.emit_consts
** rewrite getconst emit
* add TN to generated ids
** add/parse_fimp
* add read-iter to io lib
** convert read to iter
*** keep bin ref
** update example and add to post
* add MFile based on cx_buf
** derive RWFile
* add seq zip/unzip fns
* add and/or tests
* add filter tests
* add ^ (pow)
** add as separator
** implement for int/rat in math
* add vect put/get fns
* add rat sub/div
** move fns to math lib
* implement Cmp for Sym/Guid
* use cx_str for CX_TID
** remove cx_tok.as_ptr
** replace with cx_tok.as_str, as_func, as_fimp etc.
* replace box.as_ptr with as_func/fimp/etc
* add seek(file, pos) fn
* add tell(file) fn
* add len(file) fn
* convert repl to use getline
* change funcs to take cx instead of scope
** grep all cx_scope *
** use cx_scope to get current
* add @@ char escape
* more qdb
** add find-key(Vect) fn
** add is-dirty fn
** add delete fn
* add support for untyped func: arg list tails
** default to A

| Bin new % 'func: foo() (Int) 42; &foo call say' compile emit
| Bin new % 'func: foo() (Int) 42; &foo call' compile emit

| Bin new % 'func: foo(x y Int) (Int) 35 $y +; 35 7 foo' compile emit

| Bin new % '1 2 +' compile emit
| Bin new % '1000000000 {50 fib _} clock / int<Rat>' compile emit
| Bin new % '#out 42 print<WFile A>' compile emit
| Bin new % '42 say' compile emit
| Bin new % '{10000 {50 fib _} times} clock 1000000 / int say' compile emit
| {10000 {50 fib _} times} clock 1000000 / int say

{10000000 {Foo new % `x 42 put<Rec A> `y 'bar' put<Rec A>} times} clock 1000000 / int
