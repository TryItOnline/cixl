* change str to use nrefs
** add struct cx_str
*** data, len & nrefs
*** get len on demand
* add Ref type
* add type.new
** implement for all types
** replaces Rec fn
** Bin new compile ''
* add Guid type
* add Iter type
** add struct cx_iter
*** bool (*next)()
**** next is responsible for pushing values
** implement for Vect/Str/Int
** implement for Rec
*** push field ids
** extract common for loop
** extract common map fn
*** keep Str override
* investigate inlining lambdas
* add Table type
** extract cx_table from Rec
** allow specifying key
** add $resources table
* implement Cmp for Sym/Vect/Rec
* add type: macro
** type: Size Int
*** size 42 -> Size(42)
*** inherit and register conversion fns
* add ^ (pow)
** add as separator
** implement for int/rat in math
* add rat sub/div
** move fns to math lib

* add lets: macro
** typecheck and bind stack to vars
* add case: macro
** case: 
(= 1 2) 42
$foo ('foo' $foo vect)
$bar ('bar' $bar vect)
#t 'default'
** execute first clause that tests ok
** error if no match 
* add vect get
** add vect lib
* add str interpolation
* add call stack
** log function calls with func/row/col
** copy to error struct
** print in repl
* add Stream type
** cx_stream with byte vec & r/w pos
** stream fn to create
** stream '...' write fn
** stream rseek/wseek fn
** stream str fn
** stream len fn
