* rename test to check
* rename type.print to dump
* meta lib with read-iter
** move read and convert to iter
*** keep bin ref in iter
* add iter zip/unzip
* add and/or tests
* add filter tests
* extract cond lib with if/?/!
* add type: macro
** type: Size Int
*** size 42 -> Size(42)
*** inherit and register conversion fns
* add ^ (pow)
** add as separator
** implement for int/rat in math
* add seek(File offs)
** seek from start
* add len(File)
*** save offs end seek 0 from end

* add vect put/get fns
* add rat sub/div
** move fns to math lib

* add lets: macro
** typecheck and bind stack to vars
* implement Cmp for Sym/Guid/Vect/Rec
* use cx_str for CX_TID
** remove cx_tok.as_ptr
** replace with cx_tok.as_str, as_func, as_fimp etc.
* replace box.as_ptr with as_func/fimp/etc
* implement type.new for Int/Str/Rat/Time
** execute first clause that tests ok
** error if no match 
* add str interpolation
* add Ref type

* add switch: macro
** var is optional
*** bind if not bound already
*** push before groups/funcs/fimps
** add cond lib
** if cond is group, eval
*** with g pushed if present
** if cond is literal, compare with =
*** only if var is present
** if cond is func/fimp, call
** if cond is $id, compare with =
*** only if var is present
** if #t, eval unconditionally
** allow single token actions
*** call eval_token instead
