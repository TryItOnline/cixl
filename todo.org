* add cx_bin_init_ops
** move row/col init
** add op_type.init
*** void (op *, tok *)
** add bin.init_offs
*** default 0
** call from eval/emit
** move tok->as_box to ops
*** copy/deinit
* --
* implement Char emit
* implement oreturn emit
* implement fib emit
* add emit init
** add cx.emit_inits
*** set of eval ptrs
*** add bool cx_emit_init(eval) fn
**** set true & return true if insert ok
*** check in emit fn before init block
* implement func: emit
** register all funcs from bin in outer eval
* implement trait: & rec: emit
** register in bin & create in init
* implement -e flag
** generate nested fns with switch
** generate main
*** include all libs
** link with libcixl.a to a.out
** add -o X option
*** pass to gcc
** add -h option
*** print usage
* --
* add TN to generated ids
** add/parse_fimp
* add read-iter to io lib
** convert read to iter
*** keep bin ref
** update example and add to post
* more qdb
** add find-key(Vect) fn
** add is-dirty fn
** add delete fn
* add MFile based on cx_buf
** derive RWFile
* add seq zip/unzip fns
* add and/or tests
* add filter tests
* add ^ (pow)
** add as separator
** implement for int/rat in math
* add vect put/get fns
* add rat sub/div
** move fns to math lib
* implement Cmp for Sym/Guid
* use cx_str for CX_TID
** remove cx_tok.as_ptr
** replace with cx_tok.as_str, as_func, as_fimp etc.
* replace box.as_ptr with as_func/fimp/etc
* add seek(file, pos) fn
* add tell(file) fn
* add len(file) fn
* reuse stack values in imps
** go through all fns used in fib
** go through libs
* convert repl to use getline
* change funcs to take cx instead of scope
** grep all cx_scope *
** use cx_scope to get current

| Bin new %, $ compile '#out print<WFile A> 42' emit
| Bin new %, $ compile 'say 42' emit
| Bin new %, $ compile 'say (clock {10000 times {50 fib _}} / 1000000 int)' emit
