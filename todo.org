* add isfunc/unfunc fns
** extract func lib
* add $N-support
** parse integer if first char is numeric
** index stack from end
** update cut_offs
* add type: macro
** type: Size Int
*** size 42 -> Size(42)
*** inherit and register conversion fns
* add ^ (pow)
** add as separator
** implement for int/rat in math
* add rat sub/div
** move fns to math lib
* change str to use nrefs
** add struct cx_str
*** data, len & nrefs
*** get len on demand
* add lets: macro
** typecheck and bind stack to vars
* add case: macro
** case: 
(= 1 2) 42
$foo ('foo' $foo vect)
$bar ('bar' $bar vect)
#t 'default'
** execute first clause that tests ok
** error if no match 
* add vect get
** add vect lib
* add str interpolation
* add Stream type
** cx_stream with byte vec & r/w pos
** stream fn to create
** stream '...' write fn
** stream rseek/wseek fn
** stream str fn
** stream len fn
* add type.cmp
** add Cmp trait
** use to implement < > <= >= for all Cmp types
** use as fallback for eqval
** replaces int/rat imps
** add cx_init_cmp_type
* add Table type
* add fail func
** like test but just call error with message

| clock {,10000 times {50 fib _}} / 1000000 int
| clock {(let: v []; 10000000 for {$v ~ push})} / 1000000 int
| rec: Foo() x Int y Str; clock {10000000 times {Foo new % `x 42 put `y 'bar' put}} / 1000000 int
