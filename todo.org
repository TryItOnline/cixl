#define htonll(x) ((1==htonl(1)) ? (x) : ((uint64_t)htonl((x) & 0xFFFFFFFF) << 32) | htonl((x) >> 32))
#define ntohll(x) ((1==ntohl(1)) ? (x) : ((uint64_t)ntohl((x) & 0xFFFFFFFF) << 32) | ntohl((x) >> 32))
host64 & net64 fns

* mandelbrot improvements
** switch to using image frame
*** add fold-down(Frame y1 y2 n) fn
* ---
* throw error on dup rec field
* add support for empty rec: defs
* add cx_type.has_refs
** fill in when args are pushed
** replaces cx_type_has_refs fn
** check as fast path in resolve
* add cx_call_copy
** copy args properly
** use in error
*** update error print to include args
*** deinit calls in error_deinit
* finish type-id parents
** resolve parents with refs and derive
*** check all types in set against parents
* resolve rec/type-id parent types using type args
* move macro processing to TID compile
** remove macro_eval type
** remove TMACRO type
** take tok seq as macro input
** rewrite macros
* ---
* replace cx_fimp.init with enum cx_fimp_type
** CX_FHOST_C, CX_FHOST_CX, CX_FGUEST
* remove Rec =/?/print overloads
** handle in type methods
*** check if user defined func exists
* move poll/term/buf libs out of io
* replace box.as_ptr with as_func/fimp/etc
* change cx_type to use ref counting
** add nrefs
** replace reinit with deref & new
* replace cx_tok.as_ptr with as_id, as_literal etc.
** use cx_sym for CX_TID?
* convert type id to sym
* convert macro id to sym
* convert func id to sym
* convert repl to use getline
* optimize const emit
** add op_type.emit_consts
*** rewrite getconst emit
** add cx_getconst_op.value
*** set in parse_const
*** change eval to push value
* replace clone fallback to copy with error
* replace varargs with size/array+macro
* --- cxcrypt
* add Pub/PrivKey
* add README/LICENSE

