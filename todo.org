* add find-key(Vect) fn & post
* add is-dirty fn
* add revert(table rec) fn
** add Rec iter
*** copy Table
** put all fields
* linearize scan_args
** add cx_scan struct
** add cx.scans vec
** func & opt return_op
** check in cx_push and call if enough args
** change funcall to call scan_args
** change scan_args to push struct
* add switch: macro
** var is optional
*** bind if not bound already
*** push before groups/funcs/fimps
** add cond lib
** if cond is group, eval
*** with g pushed if present
** if cond is literal, compare with =
*** only if var is present
** if cond is func/fimp, call
** if cond is $id, compare with =
*** only if var is present
** if #t, eval unconditionally
** allow single token actions
*** call eval_token instead

* add qdb.delete
* meta lib with read-iter
** move read and convert to iter
*** keep bin ref in iter
* add MemFile based on cx_buf
** derive RWFile
* investigate threading cx_eval
** use computed goto
** assign labels to ops before loop
* add Vect alloc
* add iter zip/unzip
* add and/or tests
* add filter tests
* add ^ (pow)
** add as separator
** implement for int/rat in math
* add seek(File offs)
** seek from start
* add len(File)
*** save offs end seek 0 from end

* add vect put/get fns
* add rat sub/div
** move fns to math lib

* add lets: macro
** typecheck and bind stack to vars
* implement Cmp for Sym/Guid
* use cx_str for CX_TID
** remove cx_tok.as_ptr
** replace with cx_tok.as_str, as_func, as_fimp etc.
* replace box.as_ptr with as_func/fimp/etc
* add str interpolation
