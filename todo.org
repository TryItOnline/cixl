#define htonll(x) ((1==htonl(1)) ? (x) : ((uint64_t)htonl((x) & 0xFFFFFFFF) << 32) | htonl((x) >> 32))
#define ntohll(x) ((1==ntohl(1)) ? (x) : ((uint64_t)ntohl((x) & 0xFFFFFFFF) << 32) | ntohl((x) >> 32))
host64 & net64 fns

* add throw(Error) fn
** add rethrow test
* add support for trait type args
** rename trait: to type-id:
** resolve types and derive in type_init
* add type: macro
** add CX_TYPE
** type: Enc Str Int;
** copy type-id
** declare enc(Str)->Enc<Str> and enc(Int)->Enc<Int> fns
** derive Enc<Str> from Str and Enc<Int> from Int
** add support in OTYPEDEF
** add qdb.DBKey type
* --
* add cx_call.args
** add struct cx_call_arg (type & value)
** move values from stack & init resolved types on call init
** change OPUTARGS to use call instead of stack
** use instead of vars for arg refs in ORETURN
** refill on recall
* enable using Arg refs inside funcs
** add bool cx_is_arg_ref(type) fn
*** search all args recursively for CX_TYPE_ARG
** add OARGDEREF op
*** create with imp
*** resolve type using imp & call args
** walk fimp ops after compile & switch type OPUSH(Type) to OARGDEREF
* add rec type to qdb DBTable
** set recs type from table
** update qdb funcs
** update collabri
*** use init-table
* add support for type arg wildcards
** use _
** forward NULL type
** make sure that nargs == raw in cx_type_vget
** change cloning in cx_type_vget to replace NULL with raw arg
* update cxcrypt
* --
* --
* add implicit lambda scope
** one scope per lambda
** set parent
** install on call
** shuffle all values on stack back and forth
** replace scope.parents with plain parent ptr
* replace cx_fimp.init with enum cx_fimp_type
** CX_FHOST_C, CX_FHOST_CX, CX_FGUEST
* remove Rec =/?/print overloads
** handle in type methods
*** check if user defined func exists
* move poll/term/buf libs out of io
* add Table emit support
** copy Rec
* replace box.as_ptr with as_func/fimp/etc
* change cx_type to use ref counting
** add nrefs
** replace reinit with deref & new
* add cxtls project
** use gnutls
** integrate into poll framework
** https://github.com/abligh/tlsproxy
* replace cx_tok.as_ptr with as_id, as_literal etc.
** use cx_sym for CX_TID?
* convert type id to sym
* convert macro id to sym
* convert func id to sym
* convert repl to use getline
* optimize const emit
** add op_type.emit_consts
*** rewrite getconst emit
** add cx_getconst_op.value
*** set in parse_const
*** change eval to push value
* replace clone fallback to copy with error
* replace varargs with size/array+macro
* convert size_t to ssize_t and remove unsigned
* add slurp types Int*/Str*/Arg*
** derive from all parent slurp types
*** hook into derive/underive
** handle in cx_get_type
** create on demand
** tag types with slurp flag
** handle in cx_type_vget()
*** slurp all args
* --- cxcrypt
* add Pub/PrivKey
* add README
** add LICENSE
* add automatic chunking to encrypt/decrypt
** add #max-chunk
** add int net/host
** read/write size prefixed chunks
** add buf tests
** seek 0 from end before reading into buffer
*** remember prev pos and restore
*** advance pos on write-bytes
