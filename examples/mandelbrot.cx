use: cx;

define: max 4 float;
define: max-iter 570;

let: (max-x max-y) screen-size;
let: max-cx $max-x float 2 /;
let: max-cy $max-y float 2 /;
let: rows Stack<Str> new;
let: buf Buf new;
let: zoom 1 ref;

func: p(_ A)()
  $buf ~ print;

func: render()()
  $rows clear
  
  $max-y 2 / {
    let: y;
    $buf 0 seek

    $max-x {
      let: x;
      let: (zx zy) 0 float ref %%;
      let: cx $x $max-cx - $zoom deref /;
      let: cy $y $max-cy - $zoom deref /;
      let: i #max-iter ref;

      {
        let: nzx $zx deref ** $zy deref ** - $cx +;
	$zy $zx deref *2 $zy deref * $cy + set
	$zx $nzx set
        $i &-- set-call	
        $nzx ** $zy deref ** + #max < $i deref and
      } while

      let: c $i deref % -7 bsh bor 256 mod;
      $c {$x 256 mod $y 256 mod} {0 0} if-else $c new-rgb set-bg p
      @@s p
    } for

    $rows $buf str push   
  } for

  #out 1 1 move-to print
  $rows {#out ~ print} for
  $rows riter {#out ~ print} for;

#out #hide-cursor print
raw-mode

let: poll Poll new;
let: is-done #f ref;

$poll #in {
  $is-done #t set
  #in read-char _
} on-read

{
  render
  $poll 0 wait _
  $zoom &++ set-call
  $is-done deref !
} while

#out #reset-style print
#out #clear-screen print
#out 1 1 move-to print
#out #show-cursor print
normal-mode
