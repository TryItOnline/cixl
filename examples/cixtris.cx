/*
  A console Tetris clone.
  
  https://github.com/basic-gongfu/cixl#getting-started
*/

use:
  (cx/abc #t #f #nil A Bool Char Int Opt Str is-nil)
  (cx/cond ! ? = == < > <= and else if if-else min max or)
  (cx/const define:)
  (cx/error throw)
  (cx/func func:)
  (cx/gfx Color rgb xy)
  (cx/io #in #out flush read-char print unblock)
  (cx/io/term
    clear-screen hide-cursor #key-esc reset-style restore-cursor
    reverse-colors save-cursor show-cursor
    hline move-down move-left move-right move-to normal-mode raw-mode
    screen-size set-bg vline)
  (cx/io/poll Poll new on-read wait)
  (cx/iter find-if for map times while)
  (cx/math + - * ++ -- mod rand)
  (cx/rec ? print rec: get put put-call)
  (cx/ref Ref deref new ref set set-call)
  (cx/stack Stack _ ~ % %% .. repeat get last len move put stack)
  (cx/str char len)
  (cx/var let:);

/*
   These are the shapes we'll be using to represent blocks visually.
*/ 

define: shapes [
  [['**'
    '**']]

  [['****']

   ['*'
    '*'
    '*'
    '*']]

  [['  *'
    '***']

   ['*'
    '*'
    '**']

   ['***'
    '*']

   ['**'
    ' *'
    ' *']]

  [['*'
    '***']

   ['**'
    '*'
    '*']

   ['***'
    '  *']

   [' *'
    ' *'
    '**']]

  [[' *'
    '***']
    
   ['*'
    '**'
    '*']
    
   ['***'
    ' *']

   [' *'
    '**'
    ' *']]

  [[' **'
    '**']

   ['*'
    '**'
    ' *']]

  [['**'
    ' **']

   [' *'
    '**'
    '*']]
];

/*
   And these are their respective colors, the same color is always used for a
   specific shape.
*/

define: colors [
  [255 255 0]
  [0 255 255]
  [255 128 0]
  [0 0 255]
  [255 0 255]
  [0 255 0]
  [255 0 0]
] {.. rgb} map stack;

define: key-rotate @i;
define: key-left   @j;
define: key-right  @l;
define: key-drop   @k;
define: key-fast   @+;
define: key-slow   @-;
define: key-quit   #key-esc char;

define: speed-delays [200 175 150 125 100];
define: max-speed #speed-delays len --;
let: speed 0 ref;

let: max-x 30;
let: max-y screen-size ~ _;

let: tiles [] % $max-x $max-y * #nil repeat;

let: key-delay 0 ref;
let: is-done #f ref;
let: is-dropping #f ref;

/*
   Each block keeps track of its shapes, shape index, color and position.
*/

rec: Block
  shapes Stack<Stack<Str>>
  i      Int
  color  Color
  x y    Int;

let: block Ref<Block> new;
let: next-block Ref<Block> new;

func: shape-width(s Stack<Str>)(_ Int)
  0 $s {len max} for;

func: shape-height(s Stack<Str>)(_ Int)
  $s len;

/*
   New blocks get random shapes, shape indexes and x positions.
*/

func: new-block()(b Block)
  let: b Block new;
  let: si #shapes len rand;
  let: ss #shapes $si get;
  let: i $ss len rand;
  let: s $ss $i get;
  let: c #colors $si get;
  let: x $max-x rand ++ $max-x $s shape-width - min;
  
  $b `shapes $ss put
  $b `i      $i  put
  $b `color  $c  put
  $b `x      $x  put
  $b `y      1   put;

/*
   Returns the current shape for the specified block.
*/

func: get-shape(b Block)(_ Stack<Str>)
  $b % `shapes get ~ `i get get;

/*
   Since we'll be printing a lot, we reserve the letter 'p' for that purpose.
*/

func: p(_ A)()
  #out print;

func: get-offs(x y Int)(_ Int)
  $y -- $max-x * $x -- +;

/*
   Prints or erases current shape of block at current position depending on specified
   color.
*/

func: print-shape(b Block c Opt<Color>)()
  #out save-cursor
  $c {$c #out set-bg} {#out reset-style} if-else
  
  $b get-shape {
    let: l;
    
    $l {
      @* = {
        @@s p
      } {
        1 #out move-right
      } if-else
    } for

    1 #out move-down
    $l len #out move-left
  } for
  
  $c {#out reset-style} if
  #out restore-cursor;

/*
   Updates tiles for block starting at specified offset.
*/

func: update-tiles(b Block offs Int v Opt<Block>)()
  let: s $b get-shape;
  let: o $offs ref;
  
  $s {
    let: l;
    
    $l {
      @* = {$tiles $o deref $v put} if
      $o &++ set-call
    } for

    $max-x $l len - $o &+ set-call
  } for;

/*
   Prints bottom marker for block.
*/

func: print-marker(b Block)()
  #out save-cursor
  #out $b `x get $max-y xy move-to

  $b get-shape last {
    @* = {@@s p} {1 #out move-right} if-else
  } for
  
  #out restore-cursor;

func: print-block(b Block)()
  $b $b `color get print-shape
  $b print-marker
  $b % % `x get ~ `y get get-offs $b update-tiles;

func: erase-block(b Block)()
  $b #nil print-shape
  $b % % `x get ~ `y get get-offs #nil update-tiles;

/*
   Redraws all tiles.
*/

func: refresh-tiles()()
  #out save-cursor
  
  $max-y -- {
    let: y ++;
    #out 1 $y xy move-to
    
    $max-x -- {
      let: x ++;
      let: b $tiles $x $y get-offs get;
      
      $b {$b `color get #out set-bg} {#out reset-style} if-else
      @@s p
    } for
  } for

  #out reset-style
  #out restore-cursor;
  
/*
   Clears full rows intersecting current shape of block.
*/

func: clear-rows(b Block)()
  let: nrows $b get-shape shape-height;
  let: y $b `y get ref;

  $nrows {
    $y {
      let: yy;

      let: is-full $max-x -- {
        let: o ++ $yy get-offs;
	$tiles $o get is-nil
      } find-if is-nil;

      $is-full {
        $tiles 0 1 $yy get-offs $max-x move
	refresh-tiles
      } if
      
      $yy ++
    } set-call
  } times;
  
/*
   Returns #t if all tiles intersecting block starting from specified position are
   free.
*/

func: check-tiles(b Block s Stack<Str> x y Int)(_ Bool)
  let: o $x $y get-offs ref;

  $s {
    let: l;
    let: so $o deref;
    
    $l {
      @* = {
        let: bb $tiles $o deref get;
	$bb {$bb $b == !} and
      } #f if-else

      $o &++ set-call
    } find-if
    
    $o $so $max-x + set
  } find-if !;

func: next-shape(b Block)(_ Stack<Str>)
  let: ss $b `shapes get;
  $ss $b `i get ++ $ss len mod get;

func: rotate-block(b Block)()
  $b `i {++ $b `shapes get len mod} put-call;

func: refresh-speed()()
  #out save-cursor
  #out $max-x 2 + 3 xy move-to
  #out reset-style
  $speed deref ++ #out print
  #out restore-cursor;

func: refresh-next-block(b Block)()
  #out save-cursor
  #out $max-x 2 + 6 xy move-to
  #out reset-style

  $next-block {
    % {#nil print-shape} &_ if-else
    $b % `color get print-shape
    $b
  } set-call
  
  #out restore-cursor;

func: handle-key(#key-rotate)()
   let: b $block deref;
   let: ns $b next-shape;
   let: ok $b $ns $b % `x get ~ `y get check-tiles;

   $ok {$b `x get $ns shape-width + $max-x <=} and {
     $b % erase-block rotate-block
   } if;
   
func: handle-key(#key-left)()
  let: b $block deref;
  
  $b `x {
    let: x;
	
    $x 1 > {
      let: nx $x --;
      
      $b $b get-shape $nx $b `y get check-tiles {
        $b erase-block
        $nx
      } $x if-else
    } $x if-else
  } put-call;

func: handle-key(#key-right)()
  let: b $block deref;
  let: s $b get-shape;
  
  $b `x {
    let: x;
	
    $x $max-x $s shape-width - < {
      let: nx $x ++;
      
      $b $b get-shape $nx $b `y get check-tiles {
        $b erase-block
        $nx
      } $x if-else
    } $x if-else
  } put-call;

func: handle-key(#key-drop)()
  $is-dropping #t set;

func: handle-key(#key-fast)()
  $speed {
    let: s;
    $s #max-speed < {$s ++} $s if-else
  } set-call

  refresh-speed;

func: handle-key(#key-slow)()
  $speed {
    let: s;
    $s {$s --} $s if-else
  } set-call

  refresh-speed;

func: handle-key(#key-quit)()
  $is-done #t set;

func: handle-key(_ Char)()
  _;

/*
   Initialize event loop and input callback.
*/

let: poll Poll new;

#in unblock

$poll #in {
  #in read-char char handle-key
  1 $key-delay &+ set-call
} on-read

/*
   Initialize screen.
*/

raw-mode
#out clear-screen
#out hide-cursor

#out $max-x 1 xy move-to
#out reverse-colors
@@s $max-y #out vline
#out reset-style

#out $max-x 2 + 2 xy move-to
'Speed:' p
refresh-speed

#out $max-x 2 + 5 xy move-to
'Next:' p
$block new-block set
new-block refresh-next-block

func: pk(k A)()
  #out reverse-colors
  $k p
  #out reset-style;

#out $max-x 2 + $max-y 5 - xy move-to
'Use ' p #key-left pk ' and ' p #key-right pk ' to move block horizontally,' p

#out $max-x 2 + $max-y 4 - xy move-to

#key-rotate pk ' rotates and ' p #key-drop pk ' drops.' p

#out $max-x 2 + $max-y 2 - xy move-to
#key-fast pk ' and ' p #key-slow pk ' may be used to change speed.' p

#out $max-x 2 + $max-y xy move-to
'Press ' p 'Esc' pk ' to exit and restore console.' p

/*
   Main loop
*/

{
  let: b $block deref;

  $key-delay deref {
    $key-delay &-- set-call
    #out $b `x get $b `y get xy move-to
    $b print-block
  } {
    let: s $b get-shape;
    let: ok $b $s $b % `x get ~ `y get ++ check-tiles;
    $ok ! {$b `y get 1 =} and {$is-done #t set} if
    
    $ok {$b `y get $s shape-height + $max-y <} and {
      #out $b `x get $b `y get xy move-to
      $b erase-block
      $b `y &++ put-call
      1 #out move-down
      $b print-block
    } {
      $b clear-rows
      let: bb $next-block deref;
      new-block refresh-next-block
      $block $bb set
      #out $bb `x get $bb `y get xy move-to
      $bb print-block
      $is-dropping #f set
    } if-else
    
    #out flush
  } if-else

  let: sd $is-dropping deref 1 {#speed-delays $speed deref get} if-else;
  $poll $sd wait _
  
  #out 1 $max-y xy move-to
  #out reverse-colors
  @@s $max-x #out hline
  #out reset-style

  $is-done deref !
} while

/*
   Restore console
*/

#out reset-style
#out clear-screen
#out 1 1 xy move-to
normal-mode
#out show-cursor
