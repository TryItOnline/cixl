/*
  A simple log-based database.

  See https://github.com/basic-gongfu/cixl/blob/master/examples/bookings.cx for
  example of usage.

  https://github.com/basic-gongfu/cixl#getting-started
*/

/*
  Records are stored in tables indexed by record pointer and stored keys. Keys may be
  composite and are implemented as stacks of values.
*/

lib: qdb (

use: cx;

rec: DBTable()
  file RWFile
  key  Stack
  recs Table;

func: load-rec(t DBTable in A)()
  let: r $in pop;

  $r {
    $t `recs get $in $r put
  } {
    $t `recs get $in delete
  } if-else;
          
func: load-recs(t DBTable in RFile)()
  $in read {$t ~ load-rec} for;

func: new-db-table(n Str k Stack)(_ DBTable)
  let: t DBTable new;
  let: f $n `a+ fopen;
  $t `file $f        put
  $t `key  $k        put
  $t `recs Table new put
  $f 0 seek
  $t $f load-recs
  $t;

func: get-rec-key(t DBTable r A)(_ Stack)
  $t `key get {$r ~ get} map stack;

func: find-key(t DBTable k Stack)(_ Opt)
  $t `recs get $k get;

func: len(t DBTable)(_ Int)
  $t `recs get len;

/*
  The transaction contains the current set of changes.
*/

define: db-trans Stack new;

/*
  Changes are pushed for each performed table operation, and contain the information
  needed to log itself to disk or revert the table.
*/

rec: DBChange()
  table  DBTable
  key    Stack
  rec    A
  op     Sym;

func: push-change(t DBTable k Stack r A op Sym)()
  let: c DBChange new;
  $c `table $t  put
  $c `key   $k  put
  $c `rec   $r  put
  $c `op    $op put
  #db-trans $c push;

/*
  Records are looked up via the record pointer, which must remain the same;
  and cloned to enable change management.
*/

func: upsert(t DBTable r A)()
  let: rs $t `recs get;
  let: k $t $r get-rec-key;

  $rs $k {
    _ $r
    $t $k $r `update push-change
  } {
    $t $k $r `insert push-change
    $r
  } put-else;

func: commit()()
  let: dirty Table new;

  #db-trans {
    let: c;
    let: f $c `table get `file get;
    let: op $c `op get;
    let: r $op `delete = #nil {$c `rec get} if-else;
    $f $c `key get % $r push write
    $dirty $f #t put
  } for

  $dirty &x map &flush for
  #db-trans clear;

/*
  Or reverted on rollback.
*/

func: rollback()()
  #db-trans {
    let: c;
    let: op $c `op get;
    let: t $c `table get;
    let: k $c `key get;
    let: recs $t `recs get;

    switch:
      (($op `insert =)
        $recs $k delete)
      (($op `update =)
        $recs $k $c `rec get put)
      (#t
        ['Invalid op: ' $op] throw);
  } for

  #db-trans clear;
);