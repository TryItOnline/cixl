#!/usr/local/bin/cixl

/*
  The seed of a simple, text based collaboration server.

  https://github.com/basic-gongfu/cixl#getting-started
*/

use:
  (cx/abc A Bool Opt Stack Str Sym #nil #t #f is-nil)
  (cx/buf Buf push write-bytes)
  (cx/cond = == and else if if-else or switch:)
  (cx/error catch: throw dump)
  (cx/func func: recall)
  (cx/io RFile WFile ask close flush fopen include: lines print say)
  (cx/io/poll Poll delete no-write on-read on-write wait)
  (cx/iter Iter for is-done iter next while)
  (cx/net TCPClient TCPServer accept listen)
  (cx/pair x y)
  (cx/rec ? rec: get put)
  (cx/str int join split str words)
  (cx/sym sym)
  (cx/sys home-dir make-dir)
  (cx/stack _ % ~ push)
  (cx/table Table put)
  (cx/time fmt now)
  (cx/type new)
  (cx/var let:);

let: port int;

include: 'qdb.cx';
use: (qdb commit find-key len new-db-table upsert);

func: get-path(n Str)(_ Str)
  [home-dir '.sircx' $n] @/ join;

'' get-path make-dir

let: options 'options.db' get-path [`id] new-db-table;
let: users 'users.db' get-path [`name] new-db-table;
let: topics 'topics.db' get-path [`id] new-db-table;
let: poll Poll new;

func: get-option(id Sym)(_ Opt)
  let: rec $options [$id] find-key;
  $rec {$rec `value get} and;

func: set-option(id Sym v A)()
  let: rec Table new;
  $rec `id $id put
  $rec `value $v put
  $options $rec upsert;

rec: Topic ()
  id name  Sym
  parent   Topic
  children Table
  clients  Table
  log-path Str
  log      WFile;

let: root Topic new;
$root `name `root put
$root `id `/ put
$root `log-path 'log' get-path put
$root `clients Table new put

func: get-log(t Topic)(_ WFile)
  $t `log get {
    let: p $t `log-path get;
    $p make-dir
    
    let: l [$p @/ $t `name get '.txt'] #nil join `a fopen;
    $t `log $l put
    $l
  } or;

func: save(t Topic)()
  let: rec Table new;
  $rec `id $t `id get put
  $rec `name $t `name get put
  
  let: pt $t `parent get;
  $pt {$rec `parent $pt `id get put} if
  $topics $rec upsert;

func: add-topic(pt t Topic)()
  let: pc $pt `children get;

  $pc {
    $pc $t `name get $t put
  } {
    let: pc Table new;
    $pt `children $pc put
    $pc $t `name get $t put    
  } if-else;

rec: User ()
  name  Sym;

func: load-user(rec Table)(_ User)
  let: u User new;
  $u `name $rec `name get put
  $u;

func: find-user(name Sym)(_ Opt)
  let: rec $users [$name] find-key;
  $rec {$rec load-user} and;
  
func: save(u User)()
  let: rec Table new;
  $rec `name $u `name get put
  $users $rec upsert;

func: new-user (n Sym)(_ User)
  let: u User new;
  $u `name $n put
  $u save
  $u;

rec: Client ()
  user  User
  topic Topic
  io    TCPClient
  buf   Buf;

func: new-topic(c Client n Sym)()
  let: t Topic new;  
  $t `name $n put
  $t `clients Table new put
  
  let: pt $c `topic get;
  $t `parent $pt put
  $pt $t add-topic

  $t `id [$pt `id get $n @/] #nil join sym put
  $t `log-path [$pt `log-path get $pt `name get] @/ join put
  $t save;

func: join-topic(c Client ns Str)()
  $c `topic get `clients get $c delete
  $ns 0 get @/ = {$c `topic $root put} if
  
  $ns @/ split {
    let: n;
    let: t $c `topic get;

    $n '..' = {
      $t {'Topic not found: ..' throw} else
      let: pt $t `parent get;
      $pt {'Topic not found: ..' throw} else
      $c `topic $pt put
    } {
      let: tc $t `children get;
      $tc {['Topic not found: ' $n] throw} else
    
      let: ct $tc $n sym get;
      $ct {['Topic not found: ' $n] throw} else

      $c `topic $ct put
    } if-else
  } for

  $c `topic get `clients get $c #t put;

func: join-topic(c Client t Topic)()
  let: ct $c `topic get;
  $ct {$ct `clients get $c delete} if
  $c `topic $t put
  $c `topic get `clients get $c #t put;

func: push-out(c Client v A)()
  let: buf $c `buf get;
  $buf $v push;

func: list-topics(c Client t Topic push-id Bool)()
  let: cts $t `children get;

  $cts {
    $cts {
      let: ct y;
      $c $ct #t recall
    } for
  } {
    $push-id {$c [$t `id get @@n] push-out} if
  } if-else;

func: prompt(c Client)()
  let: u $c `user get;
  
  $u {
    $c [@@ $u `name get @@s $c `topic get `id get @@s] push-out
  } {
    $c 'User: ' push-out
  } if-else;

func: disconnect(c Client)()
  let: io $c `io get;
  $poll $io delete
  $io close
  $c `topic get `clients get $c delete;

func: push-post(u User t Topic in Str)()
  $t get-log % $in print flush
  
  $t `clients get {
    let: c x;
    $c `user get $u == {$c $in push-out} else
  } for

  let: pt $t `parent get;
  $pt {$u $pt $in recall} if;

func: new-post(c Client in Str)()
  let: u $c `user get;
  let: t $c `topic get;
  $u $t
  [now '%d %H:%M ' fmt @@ $u `name get @@s $t `id get @@s $in @@n] #nil join
  push-post;

func: poll-out(c Client)()
  let: io $c `io get;

  $poll $io {
    let: buf $c `buf get;
    $io $buf write-bytes
    $buf {$poll $io no-write} else
  } on-write;

func: handle-in(c Client in Str)()
  $c `user get {
    $in {
      let: it $in iter;
      
      $it next @: = {
        let: cmd {$it next % {% @@s = {_ #nil} if} if} iter str sym;

        switch:
          (($cmd `join =)
	    $c $it str $root or join-topic)
	  (($cmd `list =)
	    $c % `topic get #f list-topics)
          (#t
            ['Invalid command: ' $cmd] throw);
      } {
        $c $in new-post
      } if-else
    } if
  } {
    $in {
      $c `user $in sym new-user put
      $root `clients get $c #t put
    } {
      $c disconnect
    } if-else
  } if-else;

func: push-error(c Client e Str)()
  $c ['Error: ' $e @@n] push-out;

func: push-error(c Client e Stack)()
  $c $e #nil join push-error;

func: new-client(io TCPClient)(_ Client)
  let: c Client new;
  let: ils $io lines;

  $c `io $io put
  $c `buf Buf new put
  $c $root join-topic
    
  $poll $io {
    let: l $ils next;

    $l is-nil {
      $ils is-done {$c disconnect} if
    } {
      catch: (A $c ~ push-error dump)
        $c $l handle-in;
      $c prompt
      $c poll-out
    } if-else
  } on-read

  $c;

['Sir.cx v0.2' @@n] say

$users len {
  ['Database Setup' @@n] say
  'Operator Name: ' ask
  let: n sym;
  $n new-user _
  `operator-name $n set-option
  [@@n 'Done!' @@n] say
} else

let: server #nil $port 3 listen;

$poll $server {
  let: io $server accept;
  $io {$io new-client % prompt poll-out} if
} on-read

['Listening on port ' $port] say
{$poll -1 wait} while