#!/usr/local/bin/cixl

/*
  The seed of a simplified IRC.

  https://github.com/basic-gongfu/cixl#getting-started
*/

use:
  (cx/abc A Opt Stack Str Sym #nil #t is-nil)
  (cx/buf Buf push write-bytes)
  (cx/cond = == else if if-else switch:)
  (cx/error fail)
  (cx/func func:)
  (cx/guid Guid)
  (cx/io RFile WFile #in #out ask close include: lines print say)
  (cx/io/poll Poll delete no-write on-read on-write wait)
  (cx/iter Iter for is-done next while)
  (cx/net TCPServer accept listen)
  (cx/rec ? rec: get put)
  (cx/str join split words)
  (cx/sym sym)
  (cx/sys home-dir make-dir)
  (cx/stack _ % ~ push)
  (cx/table Table put)
  (cx/type new)
  (cx/var let:);

include: 'qdb.cx';
use: (qdb commit len new-db-table upsert);

func: get-path(n Str)(_ Str)
  [home-dir '.ircx' $n] @/ join;

'' get-path make-dir

let: users 'users.db' get-path [`name] new-db-table;
let: topics 'topics.db' get-path [`id] new-db-table;
let: root Table new;
let: poll Poll new;

rec: Topic ()
  id name  Sym
  info     Str
  parent   Topic
  children Table;

func: save(t Topic)()
  let: rec Table new;
  $rec `id $t `id get put
  $rec `name $t `name get put
  $rec `info $t `info get put
  
  let: pt $t `parent get;
  $pt {$rec `parent $pt `id get put} if
  $topics $rec upsert;

func: add-topic(pt Opt t Topic)()
  let: pc $pt `children get;

  $pc {
    $pc $t `name get $t put
  } {
    let: pc Table new;
    $pt `children $pc put
    $pc $t `name get $t put    
  } if-else;

func: add-topic(#nil t Topic)()
  $root $t `name get $t put;

rec: User ()
  name   Sym
  topic Topic;

func: save(u User)()
  let: rec Table new;
  $rec `name $u `name get put
  let: t $u `topic get;
  $t {$rec `topic $t `id get put} if
  $users $rec upsert;

func: new-user (n Sym)(_ User)
  let: u User new;
  $u `name $n put
  $u save
  $u;

func: new-topic(u User n Sym)()
  let: t Topic new;
  let: id [];
  
  $t `name $n put
  $t `info '' put
  
  let: pt $u `topic get;
  
  $pt {
    $t `parent $pt put
    $pt $t add-topic
    $id $pt `id get push
  } {
    #nil $t add-topic
    $id '' push
  } if-else

  $id $n push
  $t `id $id @/ join sym put
  $t save;

func: join-topic(u User ns Str)()
  $ns 0 get @/ = {$u `topic #nil put} if
  
  $ns @/ split {
    let: n;
    let: ut $u `topic get;

    $n '..' = {
      $ut {'Topic not found: ..' fail} else
      $u `topic $ut `parent get put  
    } {
      $ut {
        let: tc $ut `children get;
        $tc {['Topic not found: ' $n] #nil join fail} else
    
        let: t $tc $n sym get;
        $t {['Topic not found: ' $n] #nil join fail} else

        $u `topic $t put
      } {
        let: t $root $n sym get;
        $t {['Topic not found: ' $n] #nil join fail} else      
        $u `topic $t put
      } if-else
    } if-else
  } for;

func: get-topic-id(u User)(_ Sym)
  let: t $u `topic get;
  $t {$t `id get} `/ if-else;

rec: Client ()
  user User
  in   RFile
  out  WFile
  buf  Buf;

func: push-out(c Client v A)()
  let: buf $c `buf get;

  $buf {
    let: out $c `out get;
    
    $poll $out {
      $out $buf write-bytes
      $buf {$poll $out no-write} else
    } on-write
  } else

  $buf $v push;

func: prompt(c Client)()
  let: u $c `user get;
  
  $u {
    $c $u `name get push-out
    $c @@s push-out
    $c $u get-topic-id push-out
    $c '> ' push-out
  } {
    $c 'login> ' push-out
  } if-else;

func: disconnect(c Client)()
  let: (in out) $c % `in get ~ `out get;
  $poll $in delete

  $in $out == {
    $in close
  } {
    $poll $out delete
  } if-else;

func: handle-in(c Client in Str)()
  $c `user get {
    $in {
      $in 0 get @: = {
        let: ins $in @@s split;
        let: cmd $ins next sym;

        switch:
          (($cmd `:join =)
            $c `user get $ins next join-topic)
          (#t
            ['Invalid cmd: ' $cmd] #nil join fail);
      } {
        'post' say
      } if-else
    } if
  } {
    $in {
      $c `user $in sym new-user put
    } {
      $c disconnect
    } if-else
  } if-else;

func: new-client(in RFile out WFile u Opt)()
  let: c Client new;
  let: ils $in lines;

  $c `in $in put
  $c `out $out put
  $c `buf Buf new put
  $u {$c `user $u put} if
  
  $poll $in {
    let: l $ils next;

    $l is-nil {
      $ils is-done {$c disconnect} if
    } {
      $c $l handle-in
      $c prompt
    } if-else
  } on-read

  $c prompt;

['ir.cx v0.1' @@n] say

$users len {
  ['Database Setup' @@n] say
  'Operator Name: ' ask
  sym new-user
  [@@n 'Done!' @@n] say
} else

let: u `me new-user;
$u `foo new-topic
$u 'foo' join-topic
$u `bar new-topic
$u 'bar' join-topic
commit

#in #out $u new-client

let: server #nil 7707 3 listen;

$poll $server {
      let: c $server accept;
      $c {$c $c #nil new-client} if
} on-read

{$poll -1 wait} while