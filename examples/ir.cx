#!/usr/local/bin/cixl

/*
  The seed of a simplified IRC.

  https://github.com/basic-gongfu/cixl#getting-started
*/

use:
  (cx/abc Opt Stack Str Sym #nil #t is-nil)
  (cx/cond = else if if-else switch:)
  (cx/error fail)
  (cx/func func:)
  (cx/guid Guid)
  (cx/io RFile WFile #in #out flush include: lines print say)
  (cx/io/poll Poll on-read wait)
  (cx/iter Iter for next while)
  (cx/net TCPServer accept listen)
  (cx/rec ? rec: get put)
  (cx/str join split words)
  (cx/sym sym)
  (cx/sys home-dir make-dir)
  (cx/stack _ push)
  (cx/table Table put)
  (cx/type new)
  (cx/var let:);

include: 'qdb.cx';
use: (qdb commit new-db-table upsert);

func: get-path(n Str)(_ Str)
  [home-dir '.ircx' $n] @/ join;

'' get-path make-dir

let: users 'users.db' get-path [`name] new-db-table;
let: chans 'chans.db' get-path [`id] new-db-table;
let: root Table new;

rec: Chan ()
  id name  Sym
  info     Str
  parent   Chan
  children Table;

func: save(c Chan)()
  let: r Table new;
  $r `id $c `id get put
  $r `name $c `name get put
  $r `info $c `info get put
  
  let: p $c `parent get;
  $p {$r `parent $p `id get put} if
  $chans $r upsert;

func: add-chan(p Opt c Chan)()
  let: pc $p `children get;

  $pc {
    $pc $c `name get $c put
  } {
    let: pc Table new;
    $p `children $pc put
    $pc $c `name get $c put    
  } if-else;

func: add-chan(#nil c Chan)()
  $root $c `name get $c put;

rec: User ()
  name Sym
  chan Chan;

func: save(u User)()
  let: r Table new;
  $r `name $u `name get put
  let: c $u `chan get;
  $c {$r `chan $c `id get put} if
  $users $r upsert;

func: new-user (n Sym)(_ User)
  let: u User new;
  $u `name $n put
  $u save
  $u;

func: new-chan(u User n Sym)()
  let: c Chan new;
  let: id [];
  
  $c `name $n put
  $c `info '' put
  
  let: pc $u `chan get;
  
  $pc {
    $c `parent $pc put
    $pc $c add-chan
    $id $pc `id get push
  } {
    #nil $c add-chan
    $id '' push
  } if-else

  $id $n push
  $c `id $id @/ join sym put
  $c save;

func: join-chan(u User cns Str)()
  $cns 0 get @/ = {$u `chan #nil put} if
  
  $cns @/ split {
    let: n;
    let: uc $u `chan get;

    $n '..' = {
      $uc {'Chan not found: ..' fail} else
      $u `chan $uc `parent get put  
    } {
      $uc {
        let: ccs $uc `children get;
        $ccs {['Chan not found: ' $n] #nil join fail} else
    
        let: c $ccs $n sym get;
        $c {['Chan not found: ' $n] #nil join fail} else

        $u `chan $c put
      } {
        let: c $root $n sym get;
        $c {['Chan not found: ' $n] #nil join fail} else      
        $u `chan $c put
      } if-else
    } if-else
  } for;

func: get-chan-id(u User)(_ Sym)
  let: c $u `chan get;
  $c {$c `id get} `/ if-else;

func: prompt(out WFile user Opt)()
  $user {
    $out [$user `name get @@s $user get-chan-id @> @@s] print
  } {
    $out 'login> ' print
  } if-else
  
  $out flush;

rec: Client ()
  user User
  in   Iter
  out  WFile;

let: poll Poll new;

func: handle-input(client Client in Str)()
  let: user $client `user get;

  $user {
    $in 0 get @: = {
      let: ins $in @@s split;
      let: cmd $ins next sym;

      switch:
        (($cmd `:join =)
          $u $ins next join-chan)
        (#t
          ['Invalid cmd: ' $cmd] #nil join fail);
    } {
      'message' say
    } if-else
  } {
    $client `user $in sym new-user put
  } if-else;

func: new-client(in RFile out WFile user Opt)()
  let: c Client new;
  let: ils $in lines;

  $c `in $ils put
  $c `out $out put
  $user {$c `user $user put} if
  
  $poll $in {
    let: l $ils next;
  
    $l is-nil {
      $c $l handle-input
      $out $c `user get prompt
    } else
  } on-read

  $out $c `user get prompt;

let: u `me new-user;
$u `foo new-chan
$u 'foo' join-chan
$u `bar new-chan
$u 'bar' join-chan
commit

#in #out $u new-client

let: server #nil 7707 3 listen;

$poll $server {
      let: c $server accept;
      $c {$c $c #nil new-client} if
} on-read

{$poll -1 wait} while