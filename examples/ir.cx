#!/usr/local/bin/cixl

/*
  The seed of a simplified IRC.

  https://github.com/basic-gongfu/cixl#getting-started
*/

use:
  (cx/abc A Opt Stack Str Sym #nil #t is-nil)
  (cx/buf Buf push write-bytes)
  (cx/cond = == else if if-else switch:)
  (cx/error fail)
  (cx/func func: recall)
  (cx/guid Guid)
  (cx/io RFile WFile #in #out ask close include: lines print say)
  (cx/io/poll Poll delete no-write on-read on-write wait)
  (cx/iter Iter for is-done iter next while)
  (cx/net TCPServer accept listen)
  (cx/pair x)
  (cx/rec ? rec: get put)
  (cx/str join split words)
  (cx/sym sym)
  (cx/sys home-dir make-dir)
  (cx/stack _ % ~ push)
  (cx/table Table put)
  (cx/time hour now minute)
  (cx/type new)
  (cx/var let:);

include: 'qdb.cx';
use: (qdb commit len new-db-table upsert);

func: get-path(n Str)(_ Str)
  [home-dir '.ircx' $n] @/ join;

'' get-path make-dir

let: users 'users.db' get-path [`name] new-db-table;
let: topics 'topics.db' get-path [`id] new-db-table;
let: poll Poll new;

rec: Topic ()
  id name  Sym
  parent   Topic
  children Table
  clients  Table;

let: root Topic new;
$root `id `/ put
$root `name `root put
$root `clients Table new put

func: save(t Topic)()
  let: rec Table new;
  $rec `id $t `id get put
  $rec `name $t `name get put
  
  let: pt $t `parent get;
  $pt {$rec `parent $pt `id get put} if
  $topics $rec upsert;

func: add-topic(pt t Topic)()
  let: pc $pt `children get;

  $pc {
    $pc $t `name get $t put
  } {
    let: pc Table new;
    $pt `children $pc put
    $pc $t `name get $t put    
  } if-else;

rec: User ()
  name  Sym;

func: save(u User)()
  let: rec Table new;
  $rec `name $u `name get put
  $users $rec upsert;

func: new-user (n Sym)(_ User)
  let: u User new;
  $u `name $n put
  $u save
  $u;

rec: Client ()
  user  User
  topic Topic
  in    RFile
  out   WFile
  buf   Buf;

func: new-topic(c Client n Sym)()
  let: t Topic new;  
  $t `name $n put
  $t `clients Table new put
  
  let: pt $c `topic get;
  $t `parent $pt put
  $pt $t add-topic

  $t `id [$pt `id get $n @/] #nil join sym put
  $t save;

func: pick-topic(c Client ns Str)()
  $c `topic get `clients get $c delete
  $ns 0 get @/ = {$c `topic $root put} if
  
  $ns @/ split {
    let: n;
    let: t $c `topic get;

    $n '..' = {
      $t {'Topic not found: ..' fail} else
      let: pt $t `parent get;
      $pt {'Topic not found: ..' fail} else
      $c `topic $pt put
    } {
      let: tc $t `children get;
      $tc {['Topic not found: ' $n] #nil join fail} else
    
      let: ct $tc $n sym get;
      $ct {['Topic not found: ' $n] #nil join fail} else

      $c `topic $ct put
    } if-else
  } for

  $c `topic get `clients get $c #t put;

func: push-out(c Client v A)()
  let: buf $c `buf get;
  $buf $v push;

func: prompt(c Client)()
  let: u $c `user get;
  
  $u {
    $c @@ push-out
    $c $u `name get push-out
    $c @@s push-out
    $c % `topic get `id get push-out
  } {
    $c 'User: ' push-out
  } if-else;

func: disconnect(c Client)()
  let: (in out) $c % `in get ~ `out get;
  $poll $in delete

  $in $out == {
    $in close
  } {
    $poll $out delete
  } if-else

  $c `topic get `clients get $c delete;

func: push-post(u User t Topic in Str)()
  $t `clients get {
    let: c x;
    $c `user get $u == {$c $in push-out} else
  } for

  let: pt $t `parent get;
  $pt {$u $pt $in recall} if;

func: fmt-post(c Client in Str)(_ Str)
  let: (h m) now % hour ~ minute;
  let: u $c `user get;
  let: t $c `topic get;
  [$h @: $m @@s @@ $u `name get @@s $t `id get $in @@n] #nil join;

func: new-post(c Client in Str)()
  let: u $c `user get;
  let: t $c `topic get;
  $u $t $c $in fmt-post push-post;

func: poll-out(c Client)()
  let: out $c `out get;

  $poll $out {
    let: buf $c `buf get;
    $out $buf write-bytes
    $buf {$poll $out no-write} else
  } on-write;

func: handle-in(c Client in Str)()
  $c `user get {
    $in {
      let: it $in iter;
      
      $it next @: = {
        let: ins $it @@s split;
        let: cmd $ins next sym;

        switch:
          (($cmd `pick =)
            $c $ins next pick-topic)
          (#t
            ['Invalid cmd: ' $cmd] #nil join fail);
      } {
        $c $in new-post
      } if-else
    } if
  } {
    $in {
      $c `user $in sym new-user put
      $root `clients get $c #t put
    } {
      $c disconnect
    } if-else
  } if-else;

func: new-client(in RFile out WFile)(_ Client)
  let: c Client new;
  let: ils $in lines;

  $c `in $in put
  $c `out $out put
  $c `buf Buf new put
  $c `topic $root put
  $root `clients get $c #t put
    
  $poll $in {
    let: l $ils next;

    $l is-nil {
      $ils is-done {$c disconnect} if
    } {
      $c $l handle-in
      $c prompt
      $c `buf get {$c poll-out} if
    } if-else
  } on-read

  $c;

['ir.cx v0.1' @@n] say

$users len {
  ['Database Setup' @@n] say
  'Operator Name: ' ask
  sym new-user _
  [@@n 'Done!' @@n] say
} else

let: u `me new-user;
let: c #in #out new-client;
$c `user $u put

$c `foo new-topic
$c 'foo' pick-topic
$c `bar new-topic
$c 'bar' pick-topic
commit

$c % prompt poll-out

let: server #nil 7707 3 listen;

$poll $server {
      let: io $server accept;
      $io {$io $io new-client % prompt poll-out} if
} on-read

{$poll -1 wait} while